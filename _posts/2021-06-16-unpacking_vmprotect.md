# "unpacking" VMProtect 

On my recent oncall rotation I was hit with a VMProtect packed ffdroid sample in T92023736. The teardown report for the sample can be found here, but this was my first time being faced with a VMProtect packed sample, so I figured I'd write up the details of my specific methodology of getting the sample to a largely "debuggable" state which allowed me to glean the behavior of the binary.
# Section on what is VMProtect, and very loosley how does it work. Rolf Rolles has a great guide on all of the vmprotect things here (https://www.msreverseengineering.com/blog/2014/6/23/vmprotect-part-0-basics). Maybe cherry pick a few things from there about what it is.
There's quite a few videos that offer suggestions on how to get started with unpacking VMProtect, like this one. They may be worth checking out, but I found the majority of them to be hit or miss with how much they'll actually get unpacked. One theme that seemed largely common was to start out by breaking on VirtualProtect, and then follow the `.text` segment in a raw memory dump. For this walk through I'll be using x64dbg, as I continually forget how to use WinDBG.
# Image of breaking on Virtual Protect, with following the text segment in the memory dump
Now go ahead and run your sample. You _should_ hit `VirtualProtect` a couple of times, but after a few hits you should see that the `.text` segment is full of machine code. Dope, this means that we've got at least _some_ user code back. 
At this point you _could_ dump the `.text` segment and start investigating around the sample in IDA, but there'll be quite a few things missing. Specifically we don't know where OEP (Original Entry Point) is, and without it IDA won't be able to disassemble _all_ of our binary, further it'll be pretty confusing what's happening. Second, we don't have an IAT for all of our library imports, which is incredibly important for quickly reversing Windows samples. As such, it behoves us to try and get our sample to unfold itself a bit more before starting our reversing.
I recalled a conversation I had with Wesley some time ago about reversing VMProtect samples, and he mentioned there was a talk a bit ago that walked through how another engineer had done this, specifically they noted breaking on ExitThread can be used, as at some point threads gotta exit. I thought this was worth giving a shot, so let's try.
# Image of breaking on RtlExitThread
Neat! We at least hit our breakpoint. Now it's simply a matter of trying to understand _who_ is exiting, and if this can get us closer to user land code. If we walk up the stack, we should be able to trace through frames and find our way (hopefully) into user code somewhere..
# Image of the stack trace up and finding some OEP candidates
So we see there's quite a few that we hop around at. At this point you could make an attempt at setting the OEP to any of these spots and making a dump. If you're using x64dbg, and try to generate the dump with Scylla, you might notice that it's finding the import table at XXXXX. This is quite a ways out, and actually just looks like the Import table that's used by the packer code..
# More details.. I gotta recall if I made dumps or what, I think I was just looking through strings, and I found the fortunately decrypted import strings at an offset that was inside of the .text segment. I tried manually setting the Scylla IAT dump there, and this worked! I was at the very least able to get a dump that had _some_ imports setup correctly
Cool, so we have a dump, it has an IAT (we'll see soon that this is partial), and now we can check out if the OEP we've identified actually is the OEP or not. 
# It's not
So while ExitThread at least got us _into_ the text segment, we now have some decrypted API function imports, let's try breaking on those to see if we can get any further. I chose `CreateThread` sort of fortunately, and this got me _much_ closer to the OEP. I found this by walking back up the stack on the first CreateThread call that had some return values close to user code (0x4XXXX or whatever) and tracing up the stack landed me at `sub_0XADDROFINIT`.  Looking at this function in IDA, it looks like some of the structure was recognized, at least enough that IDA can name it
# Image of init_terme or whatever
Looking up this function (I didn't know what it was on first glance) turns out this is actually used very early in the program initialization routines. Neat! This means we're super close to OEP, as we're _prior_ to main begin called. tracing the execution a little further lands us at this subroutine (Look up the OEP main you found and put it here)
Rockin, so we have our OEP, we have a partially working IAT, enough so that we can at least glean some functionality, so let's start reversing
# Mention the decrypt function
While we've uncovered some of the programs original functionality, a great deal of API calls are still hidden behind VMProtects translated IAT (?? What is it really, is it a lookup table? Is it the virtualization bit?). We're able to identify these by looking for subroutines that IDA chokes on, and then we can use x64dbg to trace all the way through the translation/lookup that happens, you'll eventually land on an API call. it's arduous work, but via debugging you can slowly uncover these virtualized wrappers that obfuscate the API calls, and you can annotate things enough to understand what's happening.
The
